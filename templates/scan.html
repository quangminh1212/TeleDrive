{% extends "base.html" %}

{% block title %}Channel Scanner - TeleDrive{% endblock %}

{% block content %}
<div class="main-content">
    <!-- Hero Section -->
    <div class="scan-hero">
        <div class="hero-content">
            <div class="hero-icon">
                <span class="material-icons">radar</span>
            </div>
            <h1 class="hero-title">Channel Scanner</h1>
            <p class="hero-subtitle">Discover and organize files from Telegram channels with ease</p>
        </div>
        <div class="hero-stats">
            <div class="stat-card">
                <span class="stat-number" id="total-scans">0</span>
                <span class="stat-label">Total Scans</span>
            </div>
            <div class="stat-card">
                <span class="stat-number" id="total-files">0</span>
                <span class="stat-label">Files Found</span>
            </div>
            <div class="stat-card">
                <span class="stat-number" id="total-channels">0</span>
                <span class="stat-label">Channels</span>
            </div>
        </div>
    </div>

    <div class="scan-container">
        <!-- Quick Start Section -->
        <div class="quick-start-section">
            <div class="scan-card modern-card">
                <div class="card-header">
                    <div class="header-content">
                        <div class="header-icon">
                            <span class="material-icons">rocket_launch</span>
                        </div>
                        <div class="header-text">
                            <h3>Quick Start</h3>
                            <p>Start scanning a Telegram channel in seconds</p>
                        </div>
                    </div>
                </div>
                <div class="card-body">
                    <form id="scan-form" class="modern-form">
                        <!-- Channel Input -->
                        <div class="form-group enhanced">
                            <label for="channel-input" class="form-label">
                                <span class="material-icons">link</span>
                                Channel URL or Username
                            </label>
                            <div class="input-wrapper">
                                <input type="text" id="channel-input" class="form-input modern-input"
                                       placeholder="@channelname or https://t.me/channelname" required>
                                <div class="input-icon">
                                    <span class="material-icons">search</span>
                                </div>
                            </div>
                            <div class="form-help">
                                <span class="material-icons">info</span>
                                <div class="help-content">
                                    <p>Supported formats:</p>
                                    <ul>
                                        <li><code>@channelname</code> - Channel username</li>
                                        <li><code>https://t.me/channelname</code> - Public channel link</li>
                                        <li><code>https://t.me/joinchat/xxxxx</code> - Private channel invite</li>
                                    </ul>
                                </div>
                            </div>
                        </div>

                        <!-- Advanced Options Toggle -->
                        <div class="advanced-toggle">
                            <button type="button" class="toggle-btn" onclick="toggleAdvancedOptions()">
                                <span class="material-icons">tune</span>
                                <span class="toggle-text">Advanced Options</span>
                                <span class="material-icons toggle-arrow">expand_more</span>
                            </button>
                        </div>

                        <!-- Advanced Options -->
                        <div class="advanced-options" id="advanced-options" style="display: none;">
                            <div class="options-grid">
                                <!-- Max Messages -->
                                <div class="form-group">
                                    <label for="max-messages" class="form-label">
                                        <span class="material-icons">numbers</span>
                                        Message Limit
                                    </label>
                                    <div class="input-wrapper">
                                        <input type="number" id="max-messages" class="form-input modern-input"
                                               placeholder="All messages" min="1" max="100000">
                                        <div class="input-suffix">messages</div>
                                    </div>
                                    <div class="form-help">
                                        <span class="material-icons">info</span>
                                        Leave empty to scan all messages
                                    </div>
                                </div>

                                <!-- Scan Direction -->
                                <div class="form-group">
                                    <label class="form-label">
                                        <span class="material-icons">sort</span>
                                        Scan Direction
                                    </label>
                                    <div class="radio-group">
                                        <label class="radio-item">
                                            <input type="radio" name="scan-direction" value="newest" checked>
                                            <div class="radio-custom"></div>
                                            <span>Newest First</span>
                                        </label>
                                        <label class="radio-item">
                                            <input type="radio" name="scan-direction" value="oldest">
                                            <div class="radio-custom"></div>
                                            <span>Oldest First</span>
                                        </label>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- File Types Selection -->
                        <div class="form-group">
                            <label class="form-label">
                                <span class="material-icons">category</span>
                                File Types to Include
                            </label>
                            <div class="file-types-grid">
                                <label class="file-type-card">
                                    <input type="checkbox" name="file-types" value="documents" checked>
                                    <div class="file-type-content">
                                        <div class="file-type-icon documents">
                                            <span class="material-icons">description</span>
                                        </div>
                                        <span class="file-type-name">Documents</span>
                                        <span class="file-type-desc">PDF, DOC, TXT, etc.</span>
                                    </div>
                                    <div class="file-type-check">
                                        <span class="material-icons">check</span>
                                    </div>
                                </label>

                                <label class="file-type-card">
                                    <input type="checkbox" name="file-types" value="photos" checked>
                                    <div class="file-type-content">
                                        <div class="file-type-icon photos">
                                            <span class="material-icons">image</span>
                                        </div>
                                        <span class="file-type-name">Photos</span>
                                        <span class="file-type-desc">JPG, PNG, GIF, etc.</span>
                                    </div>
                                    <div class="file-type-check">
                                        <span class="material-icons">check</span>
                                    </div>
                                </label>

                                <label class="file-type-card">
                                    <input type="checkbox" name="file-types" value="videos" checked>
                                    <div class="file-type-content">
                                        <div class="file-type-icon videos">
                                            <span class="material-icons">movie</span>
                                        </div>
                                        <span class="file-type-name">Videos</span>
                                        <span class="file-type-desc">MP4, AVI, MKV, etc.</span>
                                    </div>
                                    <div class="file-type-check">
                                        <span class="material-icons">check</span>
                                    </div>
                                </label>

                                <label class="file-type-card">
                                    <input type="checkbox" name="file-types" value="audio" checked>
                                    <div class="file-type-content">
                                        <div class="file-type-icon audio">
                                            <span class="material-icons">audiotrack</span>
                                        </div>
                                        <span class="file-type-name">Audio</span>
                                        <span class="file-type-desc">MP3, WAV, FLAC, etc.</span>
                                    </div>
                                    <div class="file-type-check">
                                        <span class="material-icons">check</span>
                                    </div>
                                </label>
                            </div>
                        </div>

                        <!-- Action Buttons -->
                        <div class="form-actions enhanced">
                            <button type="submit" class="btn btn-primary btn-large">
                                <span class="material-icons">play_arrow</span>
                                <span class="btn-text">Start Scanning</span>
                                <div class="btn-ripple"></div>
                            </button>
                            <button type="button" class="btn btn-secondary" onclick="resetForm()">
                                <span class="material-icons">refresh</span>
                                Reset
                            </button>
                            <button type="button" class="btn btn-outline" onclick="saveAsTemplate()">
                                <span class="material-icons">bookmark</span>
                                Save Template
                            </button>
                        </div>
                    </form>

                    <!-- Loading Overlay -->
                    <div class="form-loading-overlay" id="form-loading-overlay" style="display: none;">
                        <div class="loading-content">
                            <div class="loading-spinner">
                                <div class="spinner"></div>
                            </div>
                            <div class="loading-text">
                                <div class="loading-title">Starting Scan...</div>
                                <div class="loading-subtitle">Connecting to Telegram servers</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Scan Progress -->
        <div class="scan-progress-section" id="scan-progress-section" style="display: none;">
            <div class="scan-card modern-card progress-card">
                <div class="card-header">
                    <div class="header-content">
                        <div class="header-icon scanning">
                            <span class="material-icons">radar</span>
                        </div>
                        <div class="header-text">
                            <h3>Scanning in Progress</h3>
                            <p id="current-channel">Analyzing channel content...</p>
                        </div>
                    </div>
                    <div class="scan-controls">
                        <button class="btn btn-danger btn-small" id="stop-scan-btn" onclick="stopScan()">
                            <span class="material-icons">stop</span>
                            Stop
                        </button>
                    </div>
                </div>
                <div class="card-body">
                    <!-- Progress Overview -->
                    <div class="progress-overview">
                        <div class="progress-circle-container">
                            <div class="progress-circle">
                                <svg class="progress-ring" width="120" height="120">
                                    <circle class="progress-ring-background" cx="60" cy="60" r="54"></circle>
                                    <circle class="progress-ring-progress" cx="60" cy="60" r="54" id="progress-ring"></circle>
                                </svg>
                                <div class="progress-center">
                                    <span class="progress-percentage" id="progress-percentage">0%</span>
                                    <span class="progress-status" id="scan-status">Starting...</span>
                                </div>
                            </div>
                        </div>

                        <div class="progress-stats-grid">
                            <div class="progress-stat">
                                <div class="stat-icon">
                                    <span class="material-icons">message</span>
                                </div>
                                <div class="stat-content">
                                    <span class="stat-number" id="messages-processed">0</span>
                                    <span class="stat-label">Messages</span>
                                </div>
                            </div>

                            <div class="progress-stat">
                                <div class="stat-icon">
                                    <span class="material-icons">folder</span>
                                </div>
                                <div class="stat-content">
                                    <span class="stat-number" id="files-found">0</span>
                                    <span class="stat-label">Files Found</span>
                                </div>
                            </div>

                            <div class="progress-stat">
                                <div class="stat-icon">
                                    <span class="material-icons">speed</span>
                                </div>
                                <div class="stat-content">
                                    <span class="stat-number" id="scan-speed">0</span>
                                    <span class="stat-label">msg/sec</span>
                                </div>
                            </div>

                            <div class="progress-stat">
                                <div class="stat-icon">
                                    <span class="material-icons">schedule</span>
                                </div>
                                <div class="stat-content">
                                    <span class="stat-number" id="time-elapsed">00:00</span>
                                    <span class="stat-label">Elapsed</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Live Activity Feed -->
                    <div class="activity-feed">
                        <h4>
                            <span class="material-icons">feed</span>
                            Live Activity
                        </h4>
                        <div class="activity-list" id="activity-list">
                            <div class="activity-item">
                                <div class="activity-icon">
                                    <span class="material-icons">play_arrow</span>
                                </div>
                                <div class="activity-content">
                                    <span class="activity-text">Scan initialized</span>
                                    <span class="activity-time">Just now</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Recent Scans -->
        <div class="recent-scans-section">
            <div class="scan-card modern-card">
                <div class="card-header">
                    <div class="header-content">
                        <div class="header-icon">
                            <span class="material-icons">history</span>
                        </div>
                        <div class="header-text">
                            <h3>Recent Scans</h3>
                            <p>Your scanning history and results</p>
                        </div>
                    </div>
                    <div class="header-actions">
                        <button class="btn btn-outline btn-small" onclick="clearHistory()">
                            <span class="material-icons">clear_all</span>
                            Clear
                        </button>
                    </div>
                </div>
                <div class="card-body">
                    <div class="scans-list" id="recent-scans-list">
                        <div class="empty-state modern-empty">
                            <div class="empty-icon">
                                <span class="material-icons">radar</span>
                            </div>
                            <h4>No scans yet</h4>
                            <p>Start your first channel scan to see results here</p>
                            <button class="btn btn-primary btn-small" onclick="document.getElementById('channel-input').focus()">
                                <span class="material-icons">add</span>
                                Start First Scan
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
// Enhanced scan functionality with animations and real-time updates
let scanInterval;
let startTime;
let isScanning = false;

// Initialize page
document.addEventListener('DOMContentLoaded', function() {
    initializePage();
    loadRecentScans();
    loadStats();
});

function initializePage() {
    // Add ripple effects to buttons
    addRippleEffects();

    // Initialize file type cards
    initializeFileTypeCards();

    // Add input animations
    initializeInputAnimations();
}

function addRippleEffects() {
    document.querySelectorAll('.btn-primary').forEach(button => {
        button.addEventListener('click', function(e) {
            const ripple = this.querySelector('.btn-ripple');
            if (ripple) {
                ripple.style.left = (e.clientX - this.offsetLeft) + 'px';
                ripple.style.top = (e.clientY - this.offsetTop) + 'px';
                ripple.classList.add('active');
                setTimeout(() => ripple.classList.remove('active'), 600);
            }
        });
    });
}

function initializeFileTypeCards() {
    document.querySelectorAll('.file-type-card').forEach(card => {
        const checkbox = card.querySelector('input[type="checkbox"]');

        // Set initial state
        if (checkbox.checked) {
            card.classList.add('selected');
        }

        // Handle clicks
        card.addEventListener('click', function(e) {
            if (e.target.type !== 'checkbox') {
                checkbox.checked = !checkbox.checked;
                checkbox.dispatchEvent(new Event('change'));
            }
        });

        // Handle checkbox changes
        checkbox.addEventListener('change', function() {
            if (this.checked) {
                card.classList.add('selected');
            } else {
                card.classList.remove('selected');
            }
        });
    });
}

function initializeInputAnimations() {
    document.querySelectorAll('.modern-input').forEach(input => {
        input.addEventListener('focus', function() {
            this.parentElement.classList.add('focused');
        });

        input.addEventListener('blur', function() {
            this.parentElement.classList.remove('focused');
        });

        input.addEventListener('input', function() {
            if (this.value) {
                this.parentElement.classList.add('has-value');
            } else {
                this.parentElement.classList.remove('has-value');
            }
        });
    });

    // Add real-time validation for channel input
    const channelInput = document.getElementById('channel-input');
    if (channelInput) {
        let validationTimeout;

        channelInput.addEventListener('input', function() {
            // Clear previous validation timeout
            if (validationTimeout) {
                clearTimeout(validationTimeout);
            }

            // Remove error state immediately when user starts typing
            this.classList.remove('error');
            const wrapper = this.closest('.form-group');
            if (wrapper) {
                const errorElement = wrapper.querySelector('.field-error');
                if (errorElement) {
                    errorElement.remove();
                }
            }

            // Validate after user stops typing (debounced)
            validationTimeout = setTimeout(() => {
                validateChannelInputRealTime(this.value.trim());
            }, 500);
        });

        channelInput.addEventListener('blur', function() {
            // Immediate validation on blur
            if (validationTimeout) {
                clearTimeout(validationTimeout);
            }
            validateChannelInputRealTime(this.value.trim());
        });
    }

    // Add validation for max messages input
    const maxMessagesInput = document.getElementById('max-messages');
    if (maxMessagesInput) {
        maxMessagesInput.addEventListener('input', function() {
            validateMaxMessagesRealTime(this.value);
        });
    }
}

function toggleAdvancedOptions() {
    const options = document.getElementById('advanced-options');
    const arrow = document.querySelector('.toggle-arrow');

    if (options.style.display === 'none') {
        options.style.display = 'block';
        arrow.textContent = 'expand_less';
        arrow.parentElement.classList.add('active');
    } else {
        options.style.display = 'none';
        arrow.textContent = 'expand_more';
        arrow.parentElement.classList.remove('active');
    }
}

function resetForm() {
    document.getElementById('scan-form').reset();

    // Reset file type cards
    document.querySelectorAll('.file-type-card').forEach(card => {
        const checkbox = card.querySelector('input[type="checkbox"]');
        if (checkbox.checked) {
            card.classList.add('selected');
        } else {
            card.classList.remove('selected');
        }
    });

    // Reset input states
    document.querySelectorAll('.input-wrapper').forEach(wrapper => {
        wrapper.classList.remove('focused', 'has-value');
    });

    // Show success message
    showToast('Form reset successfully', 'success');
}

function saveAsTemplate() {
    const formData = new FormData(document.getElementById('scan-form'));
    const template = {
        channel: formData.get('channel-input') || '',
        maxMessages: formData.get('max-messages') || '',
        fileTypes: formData.getAll('file-types'),
        scanDirection: formData.get('scan-direction') || 'newest'
    };

    localStorage.setItem('scanTemplate', JSON.stringify(template));
    showToast('Template saved successfully', 'success');
}

// Form submission with enhanced validation and animation
document.getElementById('scan-form').addEventListener('submit', function(e) {
    e.preventDefault();

    if (isScanning) {
        showToast('A scan is already in progress', 'warning');
        return;
    }

    // Comprehensive form validation
    const validationResult = validateForm();
    if (!validationResult.isValid) {
        showValidationErrors(validationResult.errors);
        return;
    }

    const channelInput = document.getElementById('channel-input').value.trim();

    startScan(channelInput);
});

function validateChannelInput(input) {
    const validation = {
        isValid: false,
        error: '',
        suggestion: '',
        type: ''
    };

    if (!input || input.trim().length === 0) {
        validation.error = 'Channel input is required';
        validation.suggestion = 'Please enter a channel username or URL';
        return validation;
    }

    const trimmedInput = input.trim();

    // Define validation patterns with more specific rules
    const patterns = [
        {
            regex: /^@[a-zA-Z][a-zA-Z0-9_]{4,31}$/,
            type: 'username',
            description: 'Channel username (@channelname)'
        },
        {
            regex: /^https:\/\/t\.me\/[a-zA-Z][a-zA-Z0-9_]{4,31}$/,
            type: 'public_link',
            description: 'Public channel link'
        },
        {
            regex: /^https:\/\/t\.me\/joinchat\/[a-zA-Z0-9_-]{22}$/,
            type: 'private_invite',
            description: 'Private channel invite link'
        },
        {
            regex: /^https:\/\/t\.me\/\+[a-zA-Z0-9_-]{22}$/,
            type: 'private_invite_plus',
            description: 'Private channel invite link (+format)'
        }
    ];

    // Check each pattern
    for (const pattern of patterns) {
        if (pattern.regex.test(trimmedInput)) {
            validation.isValid = true;
            validation.type = pattern.type;
            return validation;
        }
    }

    // Provide specific error messages based on input format
    if (trimmedInput.startsWith('@')) {
        if (trimmedInput.length < 6) {
            validation.error = 'Username too short';
            validation.suggestion = 'Channel usernames must be at least 5 characters long';
        } else if (trimmedInput.length > 32) {
            validation.error = 'Username too long';
            validation.suggestion = 'Channel usernames must be 32 characters or less';
        } else if (!/^@[a-zA-Z]/.test(trimmedInput)) {
            validation.error = 'Invalid username format';
            validation.suggestion = 'Username must start with a letter after @';
        } else {
            validation.error = 'Invalid username format';
            validation.suggestion = 'Username can only contain letters, numbers, and underscores';
        }
    } else if (trimmedInput.startsWith('https://t.me/')) {
        if (trimmedInput.includes('/joinchat/')) {
            validation.error = 'Invalid invite link format';
            validation.suggestion = 'Invite links should be exactly 22 characters after /joinchat/';
        } else if (trimmedInput.includes('/+')) {
            validation.error = 'Invalid invite link format';
            validation.suggestion = 'Invite links should be exactly 22 characters after /+';
        } else {
            validation.error = 'Invalid channel link format';
            validation.suggestion = 'Channel name must be 5-32 characters, start with a letter';
        }
    } else if (trimmedInput.startsWith('http://')) {
        validation.error = 'Insecure URL';
        validation.suggestion = 'Please use HTTPS (https://t.me/...)';
    } else if (trimmedInput.includes('t.me')) {
        validation.error = 'Invalid URL format';
        validation.suggestion = 'URL must start with https://t.me/';
    } else {
        validation.error = 'Invalid format';
        validation.suggestion = 'Please enter @username or https://t.me/... link';
    }

    return validation;
}

function validateForm() {
    const result = {
        isValid: true,
        errors: []
    };

    // Clear previous validation states
    clearValidationErrors();

    // Validate channel input
    const channelInput = document.getElementById('channel-input').value.trim();
    const channelValidation = validateChannelInput(channelInput);

    if (!channelValidation.isValid) {
        result.isValid = false;
        result.errors.push({
            field: 'channel-input',
            message: channelValidation.error,
            suggestion: channelValidation.suggestion
        });
    }

    // Validate file types selection
    const selectedTypes = document.querySelectorAll('input[name="file-types"]:checked');
    if (selectedTypes.length === 0) {
        result.isValid = false;
        result.errors.push({
            field: 'file-types',
            message: 'No file types selected',
            suggestion: 'Please select at least one file type to scan for'
        });
    }

    // Validate max messages if provided
    const maxMessages = document.getElementById('max-messages').value;
    if (maxMessages && (isNaN(maxMessages) || parseInt(maxMessages) < 1 || parseInt(maxMessages) > 100000)) {
        result.isValid = false;
        result.errors.push({
            field: 'max-messages',
            message: 'Invalid message limit',
            suggestion: 'Message limit must be between 1 and 100,000'
        });
    }

    return result;
}

function showValidationErrors(errors) {
    errors.forEach(error => {
        const field = document.getElementById(error.field);
        if (field) {
            // Add error class to field
            field.classList.add('error');

            // Show error message
            showFieldError(error.field, error.message, error.suggestion);

            // Focus first error field
            if (errors.indexOf(error) === 0) {
                field.focus();
            }
        } else if (error.field === 'file-types') {
            // Special handling for file types
            showFileTypesError(error.message, error.suggestion);
        }
    });

    // Show general error toast
    const firstError = errors[0];
    showToast(firstError.message + (firstError.suggestion ? ': ' + firstError.suggestion : ''), 'error');
}

function showFieldError(fieldId, message, suggestion) {
    const field = document.getElementById(fieldId);
    const wrapper = field.closest('.form-group') || field.closest('.input-wrapper');

    if (wrapper) {
        // Remove existing error message
        const existingError = wrapper.querySelector('.field-error');
        if (existingError) {
            existingError.remove();
        }

        // Create error message element
        const errorElement = document.createElement('div');
        errorElement.className = 'field-error';
        errorElement.innerHTML = `
            <span class="material-icons">error</span>
            <div class="error-content">
                <div class="error-message">${message}</div>
                ${suggestion ? `<div class="error-suggestion">${suggestion}</div>` : ''}
            </div>
        `;

        // Insert error message
        wrapper.appendChild(errorElement);
    }
}

function showFileTypesError(message, suggestion) {
    const fileTypesContainer = document.querySelector('.file-types-grid');
    if (fileTypesContainer) {
        fileTypesContainer.classList.add('error');

        // Show error message above file types
        const wrapper = fileTypesContainer.closest('.form-group');
        if (wrapper) {
            showFieldError('file-types-container', message, suggestion);
        }
    }
}

function clearValidationErrors() {
    // Remove error classes
    document.querySelectorAll('.error').forEach(element => {
        element.classList.remove('error');
    });

    // Remove error messages
    document.querySelectorAll('.field-error').forEach(element => {
        element.remove();
    });
}

function validateChannelInputRealTime(value) {
    const channelInput = document.getElementById('channel-input');
    const validation = validateChannelInput(value);

    if (value && !validation.isValid) {
        channelInput.classList.add('error');
        showFieldError('channel-input', validation.error, validation.suggestion);
    } else {
        channelInput.classList.remove('error');
        const wrapper = channelInput.closest('.form-group');
        if (wrapper) {
            const errorElement = wrapper.querySelector('.field-error');
            if (errorElement) {
                errorElement.remove();
            }
        }
    }
}

function validateMaxMessagesRealTime(value) {
    const maxMessagesInput = document.getElementById('max-messages');

    if (value && (isNaN(value) || parseInt(value) < 1 || parseInt(value) > 100000)) {
        maxMessagesInput.classList.add('error');
        showFieldError('max-messages', 'Invalid message limit', 'Must be between 1 and 100,000');
    } else {
        maxMessagesInput.classList.remove('error');
        const wrapper = maxMessagesInput.closest('.form-group');
        if (wrapper) {
            const errorElement = wrapper.querySelector('.field-error');
            if (errorElement) {
                errorElement.remove();
            }
        }
    }
}

function startScan(channelInput) {
    isScanning = true;
    startTime = Date.now();

    // Show progress section with animation
    const progressSection = document.getElementById('scan-progress-section');
    progressSection.style.display = 'block';
    progressSection.scrollIntoView({ behavior: 'smooth' });

    // Update UI
    document.getElementById('current-channel').textContent = channelInput;
    document.getElementById('scan-status').textContent = 'Initializing...';

    // Add activity
    addActivity('Starting scan request...', 'connect');

    // Start progress animation
    animateProgress();

    // Disable form elements and show loading overlay
    setFormDisabled(true, 'Initializing Scan...', 'Preparing to connect to Telegram servers');

    // Add a small delay to show the loading state
    setTimeout(() => {
        // Make actual API call to start scan
        startActualScan(channelInput);
    }, 500);
}

async function startActualScan(channelInput) {
    try {
        // Prepare scan data
        const scanData = {
            channel: channelInput,
            max_messages: document.getElementById('max-messages').value || null,
            scan_direction: document.querySelector('input[name="scan-direction"]:checked').value,
            file_types: Array.from(document.querySelectorAll('input[name="file-types"]:checked')).map(cb => cb.value)
        };

        // Get CSRF token
        const csrfToken = await getCSRFToken();

        // Make API call to start scan
        const response = await fetch('/api/start_scan', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken
            },
            body: JSON.stringify(scanData)
        });

        const data = await response.json();

        if (data.success) {
            addActivity('Scan started successfully', 'success');
            document.getElementById('scan-status').textContent = 'Connecting...';
            // SocketIO will handle progress updates from here
        } else {
            // Determine error type based on response
            let errorType = 'general';
            if (data.error && data.error.includes('CSRF')) {
                errorType = 'security_error';
            } else if (data.error && data.error.includes('already in progress')) {
                errorType = 'scan_in_progress';
            }
            handleScanError(data.error || 'Failed to start scan', errorType);
        }
    } catch (error) {
        console.error('Error starting scan:', error);
        handleScanError('Network error: Could not connect to server', 'network_error');
    }
}

function updateProgress(progress, messages, files) {
    // Update progress ring with smooth animation
    const ring = document.getElementById('progress-ring');
    if (ring) {
        const circumference = 2 * Math.PI * 54;
        const offset = circumference - (progress / 100) * circumference;
        ring.style.strokeDashoffset = offset;
    }

    // Update percentage with animation
    const percentageEl = document.getElementById('progress-percentage');
    if (percentageEl) {
        animateNumber(percentageEl, Math.round(progress), '%');
    }

    // Update stats with animation
    const messagesEl = document.getElementById('messages-processed');
    const filesEl = document.getElementById('files-found');

    if (messagesEl) {
        animateNumber(messagesEl, messages, '', true);
    }

    if (filesEl) {
        animateNumber(filesEl, files, '', true);
    }

    // Update speed and time
    const elapsed = (Date.now() - startTime) / 1000;
    const speed = Math.round(messages / elapsed);

    const speedEl = document.getElementById('scan-speed');
    const timeEl = document.getElementById('time-elapsed');

    if (speedEl) {
        animateNumber(speedEl, speed, ' msg/s');
    }

    if (timeEl) {
        timeEl.textContent = formatTime(elapsed);
    }

    // Add random activities
    if (Math.random() < 0.3) {
        const activities = [
            'Found new document',
            'Processing media files',
            'Analyzing message content',
            'Extracting file metadata'
        ];
        addActivity(activities[Math.floor(Math.random() * activities.length)], 'info');
    }
}

function completeScan(messages, files) {
    clearInterval(scanInterval);
    isScanning = false;

    document.getElementById('scan-status').textContent = 'Completed';
    addActivity(`Scan completed! Found ${files} files in ${messages} messages`, 'success');

    // Re-enable form elements
    setFormDisabled(false);

    // Update stats
    updateGlobalStats();

    // Show completion toast
    showToast(`Scan completed! Found ${files} files`, 'success');

    // Add to recent scans
    addToRecentScans({
        channel: document.getElementById('current-channel').textContent,
        files: files,
        messages: messages,
        date: new Date()
    });
}

function handleScanError(errorMessage, errorType = 'general') {
    isScanning = false;
    clearInterval(scanInterval);

    // Re-enable form elements
    setFormDisabled(false);

    // Parse and categorize error
    const errorInfo = parseErrorMessage(errorMessage, errorType);

    // Update UI
    document.getElementById('scan-status').textContent = 'Error';
    addActivity(`Error: ${errorInfo.displayMessage}`, 'error');

    // Show detailed error with recovery suggestions
    showDetailedError(errorInfo);

    // Hide progress section after a delay
    setTimeout(() => {
        const progressSection = document.getElementById('scan-progress-section');
        progressSection.style.display = 'none';
    }, 5000); // Longer delay for error messages
}

function parseErrorMessage(errorMessage, errorType) {
    const errorInfo = {
        originalMessage: errorMessage,
        displayMessage: errorMessage,
        category: 'general',
        suggestions: [],
        severity: 'error'
    };

    // Categorize common errors
    const errorPatterns = [
        {
            pattern: /channel.*not found|could not resolve/i,
            category: 'channel_not_found',
            displayMessage: 'Channel not found or inaccessible',
            suggestions: [
                'Check if the channel username or URL is correct',
                'Ensure the channel is public or you have access to it',
                'Try using the full URL format: https://t.me/channelname'
            ]
        },
        {
            pattern: /flood.*wait|rate.*limit/i,
            category: 'rate_limit',
            displayMessage: 'Rate limit exceeded',
            suggestions: [
                'Please wait a few minutes before trying again',
                'Telegram has temporary restrictions on your account',
                'Try scanning a smaller number of messages'
            ]
        },
        {
            pattern: /authentication|login|session/i,
            category: 'auth_error',
            displayMessage: 'Authentication error',
            suggestions: [
                'Please check your Telegram credentials',
                'You may need to re-authenticate with Telegram',
                'Contact support if the issue persists'
            ]
        },
        {
            pattern: /network|connection|timeout/i,
            category: 'network_error',
            displayMessage: 'Network connection error',
            suggestions: [
                'Check your internet connection',
                'Try again in a few moments',
                'The server may be temporarily unavailable'
            ]
        },
        {
            pattern: /csrf.*token/i,
            category: 'security_error',
            displayMessage: 'Security token expired',
            suggestions: [
                'Please refresh the page and try again',
                'Your session may have expired'
            ]
        },
        {
            pattern: /scan.*already.*progress/i,
            category: 'scan_in_progress',
            displayMessage: 'Another scan is already running',
            suggestions: [
                'Wait for the current scan to complete',
                'You can stop the current scan and start a new one'
            ]
        }
    ];

    // Find matching pattern
    for (const pattern of errorPatterns) {
        if (pattern.pattern.test(errorMessage)) {
            errorInfo.category = pattern.category;
            errorInfo.displayMessage = pattern.displayMessage;
            errorInfo.suggestions = pattern.suggestions;
            break;
        }
    }

    return errorInfo;
}

function showDetailedError(errorInfo) {
    // Show main error toast
    showToast(errorInfo.displayMessage, 'error');

    // Show detailed error with suggestions if available
    if (errorInfo.suggestions.length > 0) {
        const suggestionText = errorInfo.suggestions.join(' • ');

        // Create a more detailed error notification
        setTimeout(() => {
            showToast(`💡 Suggestions: ${suggestionText}`, 'info');
        }, 1000);
    }

    // Log detailed error for debugging
    console.error('Scan Error Details:', {
        category: errorInfo.category,
        original: errorInfo.originalMessage,
        display: errorInfo.displayMessage,
        suggestions: errorInfo.suggestions
    });
}

function setFormDisabled(disabled, loadingMessage = 'Starting Scan...', loadingSubtitle = 'Connecting to Telegram servers') {
    const form = document.getElementById('scan-form');
    const inputs = form.querySelectorAll('input, button, select');
    const loadingOverlay = document.getElementById('form-loading-overlay');

    inputs.forEach(input => {
        input.disabled = disabled;
    });

    // Update submit button text and state
    const submitBtn = form.querySelector('button[type="submit"]');
    if (submitBtn) {
        const btnText = submitBtn.querySelector('.btn-text');
        if (disabled) {
            btnText.textContent = 'Scanning...';
            submitBtn.classList.add('loading');
        } else {
            btnText.textContent = 'Start Scanning';
            submitBtn.classList.remove('loading');
        }
    }

    // Show/hide loading overlay
    if (loadingOverlay) {
        if (disabled) {
            // Update loading text
            const loadingTitle = loadingOverlay.querySelector('.loading-title');
            const loadingSubtitleEl = loadingOverlay.querySelector('.loading-subtitle');

            if (loadingTitle) loadingTitle.textContent = loadingMessage;
            if (loadingSubtitleEl) loadingSubtitleEl.textContent = loadingSubtitle;

            // Show overlay with animation
            loadingOverlay.style.display = 'flex';
            loadingOverlay.style.opacity = '0';
            setTimeout(() => {
                loadingOverlay.style.opacity = '1';
            }, 10);
        } else {
            // Hide overlay with animation
            loadingOverlay.style.opacity = '0';
            setTimeout(() => {
                loadingOverlay.style.display = 'none';
            }, 300);
        }
    }
}

async function getCSRFToken() {
    // Try to get CSRF token from meta tag first
    const csrfMeta = document.querySelector('meta[name="csrf-token"]');
    if (csrfMeta) {
        return csrfMeta.getAttribute('content');
    }

    // Try to get from cookie
    const cookies = document.cookie.split(';');
    for (let cookie of cookies) {
        const [name, value] = cookie.trim().split('=');
        if (name === 'csrf_token') {
            return value;
        }
    }

    // Fetch from API as fallback
    try {
        const response = await fetch('/api/csrf-token');
        const data = await response.json();
        if (data.success) {
            return data.csrf_token;
        }
    } catch (error) {
        console.warn('Could not fetch CSRF token:', error);
    }

    return '';
}

async function stopScan() {
    if (!isScanning) return;

    try {
        // Make API call to stop scan
        const csrfToken = await getCSRFToken();
        const response = await fetch('/api/stop_scan', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken
            }
        });

        const data = await response.json();

        if (data.success) {
            isScanning = false;
            setFormDisabled(false);
            document.getElementById('scan-status').textContent = 'Stopped';
            addActivity('Scan stopped by user', 'warning');
            showToast('Scan stopped', 'info');

            // Hide progress section after a delay
            setTimeout(() => {
                const progressSection = document.getElementById('scan-progress-section');
                progressSection.style.display = 'none';
            }, 2000);
        } else {
            showToast('Failed to stop scan: ' + (data.error || 'Unknown error'), 'error');
        }
    } catch (error) {
        console.error('Error stopping scan:', error);
        showToast('Network error: Could not stop scan', 'error');
    }
}

function addActivity(text, type = 'info') {
    const activityList = document.getElementById('activity-list');
    if (!activityList) return;

    const activity = document.createElement('div');
    activity.className = 'activity-item';

    const icons = {
        info: 'info',
        success: 'check_circle',
        warning: 'warning',
        error: 'error',
        connect: 'wifi'
    };

    // Get current timestamp
    const now = new Date();
    const timeString = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

    activity.innerHTML = `
        <div class="activity-icon ${type}">
            <span class="material-icons">${icons[type] || 'info'}</span>
        </div>
        <div class="activity-content">
            <span class="activity-text">${text}</span>
            <span class="activity-time">${timeString}</span>
        </div>
    `;

    // Add initial animation state
    activity.style.opacity = '0';
    activity.style.transform = 'translateX(20px)';

    activityList.insertBefore(activity, activityList.firstChild);

    // Trigger animation
    setTimeout(() => {
        activity.style.transition = 'all 0.3s ease';
        activity.style.opacity = '1';
        activity.style.transform = 'translateX(0)';
    }, 10);

    // Keep only last 10 activities with fade out animation
    while (activityList.children.length > 10) {
        const lastChild = activityList.lastChild;
        lastChild.style.transition = 'all 0.3s ease';
        lastChild.style.opacity = '0';
        lastChild.style.transform = 'translateX(-20px)';

        setTimeout(() => {
            if (lastChild.parentNode) {
                activityList.removeChild(lastChild);
            }
        }, 300);
    }
}

function animateProgress() {
    const ring = document.getElementById('progress-ring');
    const circumference = 2 * Math.PI * 54;
    ring.style.strokeDasharray = circumference;
    ring.style.strokeDashoffset = circumference;
}

function formatTime(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
}

function animateNumber(element, targetValue, suffix = '', useLocaleString = false) {
    if (!element) return;

    const currentValue = parseInt(element.textContent.replace(/[^\d]/g, '')) || 0;
    const difference = targetValue - currentValue;
    const duration = 500; // Animation duration in ms
    const steps = 20; // Number of animation steps
    const stepValue = difference / steps;
    const stepDuration = duration / steps;

    // Add animation class
    element.classList.add('updated');
    setTimeout(() => element.classList.remove('updated'), duration);

    let currentStep = 0;
    const animate = () => {
        currentStep++;
        const newValue = Math.round(currentValue + (stepValue * currentStep));

        if (useLocaleString) {
            element.textContent = newValue.toLocaleString() + suffix;
        } else {
            element.textContent = newValue + suffix;
        }

        if (currentStep < steps && newValue !== targetValue) {
            setTimeout(animate, stepDuration);
        } else {
            // Ensure final value is exact
            if (useLocaleString) {
                element.textContent = targetValue.toLocaleString() + suffix;
            } else {
                element.textContent = targetValue + suffix;
            }
        }
    };

    if (difference !== 0) {
        animate();
    }
}

function loadStats() {
    // Load global stats (replace with actual API call)
    document.getElementById('total-scans').textContent = '12';
    document.getElementById('total-files').textContent = '1,234';
    document.getElementById('total-channels').textContent = '8';
}

function updateGlobalStats() {
    // Update global stats after scan completion
    const currentScans = parseInt(document.getElementById('total-scans').textContent) || 0;
    const currentFiles = parseInt(document.getElementById('total-files').textContent.replace(',', '')) || 0;
    const currentChannels = parseInt(document.getElementById('total-channels').textContent) || 0;

    document.getElementById('total-scans').textContent = (currentScans + 1).toString();
    document.getElementById('total-files').textContent = (currentFiles + parseInt(document.getElementById('files-found').textContent.replace(',', ''))).toLocaleString();
}

function loadRecentScans() {
    // Load recent scans (replace with actual API call)
    const recentScans = JSON.parse(localStorage.getItem('recentScans') || '[]');

    if (recentScans.length === 0) {
        return; // Keep empty state
    }

    const scansList = document.getElementById('recent-scans-list');
    scansList.innerHTML = '';

    recentScans.slice(0, 5).forEach(scan => {
        const scanItem = createScanItem(scan);
        scansList.appendChild(scanItem);
    });
}

function addToRecentScans(scan) {
    const recentScans = JSON.parse(localStorage.getItem('recentScans') || '[]');
    recentScans.unshift(scan);

    // Keep only last 10 scans
    if (recentScans.length > 10) {
        recentScans.splice(10);
    }

    localStorage.setItem('recentScans', JSON.stringify(recentScans));
    loadRecentScans();
}

function createScanItem(scan) {
    const item = document.createElement('div');
    item.className = 'scan-item';

    const timeAgo = getTimeAgo(new Date(scan.date));

    item.innerHTML = `
        <div class="scan-icon">
            <span class="material-icons">folder</span>
        </div>
        <div class="scan-content">
            <div class="scan-channel">${scan.channel}</div>
            <div class="scan-stats">
                <span class="scan-stat">
                    <span class="material-icons">description</span>
                    ${scan.files} files
                </span>
                <span class="scan-stat">
                    <span class="material-icons">message</span>
                    ${scan.messages.toLocaleString()} messages
                </span>
            </div>
            <div class="scan-time">${timeAgo}</div>
        </div>
        <div class="scan-actions">
            <button class="btn btn-outline btn-small" onclick="viewScanResults('${scan.channel}')">
                <span class="material-icons">visibility</span>
                View
            </button>
        </div>
    `;

    return item;
}

function getTimeAgo(date) {
    const now = new Date();
    const diff = now - date;
    const minutes = Math.floor(diff / 60000);
    const hours = Math.floor(diff / 3600000);
    const days = Math.floor(diff / 86400000);

    if (minutes < 1) return 'Just now';
    if (minutes < 60) return `${minutes}m ago`;
    if (hours < 24) return `${hours}h ago`;
    return `${days}d ago`;
}

function viewScanResults(channel) {
    // Navigate to results page
    window.location.href = `/?search=${encodeURIComponent(channel)}`;
}

function clearHistory() {
    localStorage.removeItem('recentScans');
    document.getElementById('recent-scans-list').innerHTML = `
        <div class="empty-state modern-empty">
            <div class="empty-icon">
                <span class="material-icons">radar</span>
            </div>
            <h4>No scans yet</h4>
            <p>Start your first channel scan to see results here</p>
            <button class="btn btn-primary btn-small" onclick="document.getElementById('channel-input').focus()">
                <span class="material-icons">add</span>
                Start First Scan
            </button>
        </div>
    `;
    showToast('History cleared', 'success');
}

function showToast(message, type = 'info') {
    // Use the global toast function if available
    if (window.TeleDrive && window.TeleDrive.showToast) {
        window.TeleDrive.showToast(message, type);
    } else {
        console.log(`${type.toUpperCase()}: ${message}`);
    }
}

// SocketIO Integration for Real-time Progress Updates
let socket;

function initializeSocketIO() {
    // Initialize SocketIO connection
    socket = io();

    socket.on('connect', function() {
        console.log('Connected to server');
        addActivity('Connected to server', 'info');
    });

    socket.on('disconnect', function() {
        console.log('Disconnected from server');
        if (isScanning) {
            addActivity('Connection lost - attempting to reconnect...', 'warning');
        }
    });

    socket.on('scan_progress', function(data) {
        if (!isScanning) return;

        // Update progress based on server data
        const progress = data.total > 0 ? (data.current / data.total) * 100 : 0;
        const messages = data.current || 0;
        const files = data.files_found || 0;

        // Update status text and loading overlay based on scan phase
        let statusText = 'Scanning...';
        let loadingMessage = 'Scanning in progress...';
        let loadingSubtitle = 'Please wait while we process your request';

        switch(data.status) {
            case 'resolving_channel':
                statusText = 'Resolving channel...';
                loadingMessage = 'Connecting to Channel';
                loadingSubtitle = 'Verifying channel access and permissions';
                break;
            case 'scanning_messages':
                statusText = 'Scanning messages...';
                loadingMessage = 'Scanning Messages';
                loadingSubtitle = `Processing ${messages.toLocaleString()} messages...`;
                break;
            case 'processing_files':
                statusText = 'Processing files...';
                loadingMessage = 'Processing Files';
                loadingSubtitle = `Found ${files.toLocaleString()} files, extracting metadata...`;
                break;
            case 'saving_data':
                statusText = 'Saving data...';
                loadingMessage = 'Saving Results';
                loadingSubtitle = 'Storing scan results to database...';
                break;
        }

        // Update UI elements
        document.getElementById('scan-status').textContent = statusText;
        updateProgress(progress, messages, files);

        // Update loading overlay if visible
        const loadingOverlay = document.getElementById('form-loading-overlay');
        if (loadingOverlay && loadingOverlay.style.display !== 'none') {
            const loadingTitle = loadingOverlay.querySelector('.loading-title');
            const loadingSubtitleEl = loadingOverlay.querySelector('.loading-subtitle');

            if (loadingTitle) loadingTitle.textContent = loadingMessage;
            if (loadingSubtitleEl) loadingSubtitleEl.textContent = loadingSubtitle;
        }

        // Add activity updates with more detailed information
        if (data.status === 'scanning_messages' && messages % 100 === 0 && messages > 0) {
            addActivity(`Processed ${messages.toLocaleString()} messages, found ${files.toLocaleString()} files`, 'info');
        }

        // Add milestone activities
        if (files > 0 && files % 50 === 0 && data.status === 'processing_files') {
            addActivity(`Processed ${files} files, extracting metadata...`, 'info');
        }
    });

    socket.on('scan_complete', function(data) {
        if (data.success) {
            completeScan(data.messages_scanned || 0, data.files_found || 0);
            addActivity(`Scan completed successfully! Found ${data.files_found} files`, 'success');
        } else {
            // Determine error type from server response
            let errorType = 'general';
            if (data.error) {
                if (data.error.includes('FloodWait') || data.error.includes('rate limit')) {
                    errorType = 'rate_limit';
                } else if (data.error.includes('resolve') || data.error.includes('not found')) {
                    errorType = 'channel_not_found';
                } else if (data.error.includes('auth') || data.error.includes('login')) {
                    errorType = 'auth_error';
                }
            }
            handleScanError(data.error || 'Scan failed', errorType);
        }
    });

    socket.on('error', function(error) {
        console.error('SocketIO error:', error);
        if (isScanning) {
            handleScanError('Connection error occurred', 'network_error');
        }
    });
}

// Initialize SocketIO when page loads
document.addEventListener('DOMContentLoaded', function() {
    // Add a small delay to ensure the page is fully loaded
    setTimeout(initializeSocketIO, 100);
});
</script>
{% endblock %}
