/**
 * TeleDrive - ·ª®ng d·ª•ng qu·∫£n l√Ω file v·ªõi Telegram Bot
 * File ch√≠nh k·∫øt h·ª£p t·∫•t c·∫£ ch·ª©c nƒÉng: web server, bot Telegram, ƒë·ªìng b·ªô file v√† d·ªçn d·∫πp
 */

// Import c√°c module c·∫ßn thi·∫øt
const express = require('express');
const dotenv = require('dotenv');
const path = require('path');
const fs = require('fs');
const morgan = require('morgan');
const cors = require('cors');
const helmet = require('helmet');
const session = require('express-session');
const bodyParser = require('body-parser');

// Import c√°c module t·ª± t·∫°o
const config = require('./src/config/config');
const telegramService = require('./src/services/telegramService');
const fileService = require('./src/services/fileService');
const apiRoutes = require('./src/routes/apiRoutes');
const webRoutes = require('./src/routes/webRoutes');
const { ensureDirectories } = require('./src/utils/helpers');

// Load bi·∫øn m√¥i tr∆∞·ªùng
dotenv.config();

// ƒê∆∞·ªùng d·∫´n l∆∞u tr·ªØ v√† bi·∫øn to√†n c·ª•c
const { 
  PORT = 5002, 
  BOT_TOKEN, 
  CHAT_ID, 
  AUTO_SYNC = 'true',
  SESSION_SECRET = 'teledrive-session-secret',
  STORAGE_PATH = process.cwd()
} = process.env;

// ƒê∆∞·ªùng d·∫´n file v√† th∆∞ m·ª•c
const UPLOADS_DIR = path.join(STORAGE_PATH, 'uploads');
const TEMP_DIR = path.join(STORAGE_PATH, 'temp');
const DATA_DIR = path.join(STORAGE_PATH, 'data');
const DB_DIR = path.join(STORAGE_PATH, 'db');

// ƒê·∫£m b·∫£o c√°c th∆∞ m·ª•c t·ªìn t·∫°i
ensureDirectories([UPLOADS_DIR, TEMP_DIR, DATA_DIR, DB_DIR]);

// T·∫°o application Express
const app = express();

// Thi·∫øt l·∫≠p view engine
app.set('view engine', 'ejs');
app.set('views', path.join(__dirname, 'views'));

// Middleware
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(express.static('public'));
app.use(morgan('dev'));
app.use(helmet({
  contentSecurityPolicy: false
}));
app.use(cors());

// Thi·∫øt l·∫≠p session
app.use(session({
  secret: SESSION_SECRET,
  resave: false,
  saveUninitialized: true,
  cookie: { secure: false, maxAge: 24 * 60 * 60 * 1000 } // 24 gi·ªù
}));

// Bi·∫øn global cho bot
let bot = null;
let botActive = false;

// Middleware t·ª± ƒë·ªông check x√°c th·ª±c n·∫øu c·∫ßn
app.use((req, res, next) => {
  // Skip authentication for public routes
  if (req.path === '/login' || req.path === '/api/auth/login' || 
      req.path.startsWith('/public') || req.path.startsWith('/css') || 
      req.path.startsWith('/js') || req.path.startsWith('/img') ||
      req.path.startsWith('/api/share/')) {
    return next();
  }
  
  // Skip authentication for API routes if they have valid API key
  if (req.path.startsWith('/api/') && req.headers['x-api-key']) {
    // TODO: Implement API key validation
    return next();
  }
  
  // Redirect to login if not authenticated
  if (!req.session || !req.session.authenticated) {
    if (req.path.startsWith('/api/')) {
      return res.status(401).json({ success: false, error: 'Unauthorized' });
    } else {
      return res.redirect('/login');
    }
  }
  
  next();
});

// Router API v√† Web
app.use('/api', apiRoutes);
app.use('/', webRoutes);

// Kh·ªüi ƒë·ªông ch∆∞∆°ng tr√¨nh
(async function startApplication() {
  // Th·ª≠ kh·ªüi t·∫°o bot Telegram v·ªõi t·ªëi ƒëa 3 l·∫ßn
  let botInitAttempts = 0;
  const maxBotInitAttempts = 3;
  
  while (botInitAttempts < maxBotInitAttempts) {
    try {
      botInitAttempts++;
      console.log(`Th·ª≠ kh·ªüi t·∫°o bot l·∫ßn ${botInitAttempts}...`);
      
      if (!BOT_TOKEN || !CHAT_ID) {
        console.log('Ch∆∞a c·∫•u h√¨nh BOT_TOKEN ho·∫∑c CHAT_ID. Bot kh√¥ng ƒë∆∞·ª£c kh·ªüi t·∫°o.');
        break;
      }
      
      const result = await telegramService.startBot();
      bot = result.bot;
      botActive = result.botActive;
      
      if (botActive) {
        console.log('Bot Telegram ƒë√£ ƒë∆∞·ª£c kh·ªüi t·∫°o th√†nh c√¥ng! üéâ');
        break;
      } else {
        console.log('Kh√¥ng th·ªÉ kh·ªüi t·∫°o bot.');
        
        if (botInitAttempts < maxBotInitAttempts) {
          console.log(`Th·ª≠ l·∫°i sau ${botInitAttempts * 2} gi√¢y...`);
          await new Promise(resolve => setTimeout(resolve, botInitAttempts * 2000));
        }
      }
    } catch (error) {
      console.error('L·ªói khi kh·ªüi t·∫°o bot:', error);
      
      if (botInitAttempts < maxBotInitAttempts) {
        console.log(`Th·ª≠ l·∫°i sau ${botInitAttempts * 2} gi√¢y...`);
        await new Promise(resolve => setTimeout(resolve, botInitAttempts * 2000));
      }
    }
  }
  
  // Kh·ªüi ƒë·ªông server
  const server = app.listen(PORT, () => {
    console.log(`Server ƒëang ch·∫°y tr√™n c·ªïng ${PORT}`);
    console.log(`Truy c·∫≠p: http://localhost:${PORT}`);
  });
  
  // X·ª≠ l√Ω t√≠n hi·ªáu ƒë·ªÉ t·∫Øt server an to√†n
  process.on('SIGTERM', shutDown);
  process.on('SIGINT', shutDown);
  
  function shutDown() {
    console.log('ƒêang t·∫Øt server...');
    server.close(() => {
      console.log('Server ƒë√£ ƒë√≥ng k·∫øt n·ªëi.');
      process.exit(0);
    });
    
    // N·∫øu server kh√¥ng ƒë√≥ng trong 5s th√¨ bu·ªôc t·∫Øt
    setTimeout(() => {
      console.error('Kh√¥ng th·ªÉ ƒë√≥ng k·∫øt n·ªëi server, bu·ªôc t·∫Øt!');
      process.exit(1);
    }, 5000);
  }
  
  // B·∫Øt ƒë·∫ßu ƒë·ªìng b·ªô file v√† d·ªçn d·∫πp
  if (AUTO_SYNC === 'true') {
    setTimeout(async () => {
      try {
        await fileService.syncFiles();
      } catch (error) {
        console.error('L·ªói khi ƒë·ªìng b·ªô files l·∫ßn ƒë·∫ßu:', error);
      }
    }, 5000);
  }
  
  // ƒê·ªãnh k·ª≥ d·ªçn d·∫πp files
  const CLEANUP_INTERVAL = 24 * 60 * 60 * 1000; // 24 gi·ªù
  setInterval(async () => {
    try {
      console.log('B·∫Øt ƒë·∫ßu d·ªçn d·∫πp files...');
      await fileService.cleanupFiles();
      console.log('D·ªçn d·∫πp files ho√†n t·∫•t');
    } catch (error) {
      console.error('L·ªói khi d·ªçn d·∫πp files:', error);
    }
  }, CLEANUP_INTERVAL);
})();

// Middleware x·ª≠ l√Ω l·ªói
app.use((err, req, res, next) => {
  console.error('L·ªói server:', err);
  res.status(500).json({
    success: false,
    error: 'L·ªói server: ' + (err.message || 'Kh√¥ng x√°c ƒë·ªãnh')
  });
});

// Middleware x·ª≠ l√Ω route kh√¥ng t·ªìn t·∫°i - ph·∫£i ƒë·∫∑t sau t·∫•t c·∫£ c√°c routes
app.use((req, res) => {
  console.log(`Route kh√¥ng t·ªìn t·∫°i: ${req.method} ${req.path}`);
  res.status(404).json({
    success: false,
    error: 'API endpoint kh√¥ng t·ªìn t·∫°i'
  });
}); 